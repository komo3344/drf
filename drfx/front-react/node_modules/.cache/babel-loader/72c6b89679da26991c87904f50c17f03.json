{"ast":null,"code":"'use strict';\n\nvar stringWidth = require('string-width');\n\nvar stripAnsi = require('strip-ansi');\n\nvar ESCAPES = ['\\u001b', '\\u009b'];\nvar END_CODE = 39;\nvar ESCAPE_CODES = {\n  0: 0,\n  1: 22,\n  2: 22,\n  3: 23,\n  4: 24,\n  7: 27,\n  8: 28,\n  9: 29,\n  30: 39,\n  31: 39,\n  32: 39,\n  33: 39,\n  34: 39,\n  35: 39,\n  36: 39,\n  37: 39,\n  90: 39,\n  40: 49,\n  41: 49,\n  42: 49,\n  43: 49,\n  44: 49,\n  45: 49,\n  46: 49,\n  47: 49\n};\n\nfunction wrapAnsi(code) {\n  return ESCAPES[0] + '[' + code + 'm';\n} // calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes.\n\n\nfunction wordLengths(str) {\n  return str.split(' ').map(function (s) {\n    return stringWidth(s);\n  });\n} // wrap a long word across multiple rows.\n// ansi escape codes do not count towards length.\n\n\nfunction wrapWord(rows, word, cols) {\n  var insideEscape = false;\n  var visible = stripAnsi(rows[rows.length - 1]).length;\n\n  for (var i = 0; i < word.length; i++) {\n    var x = word[i];\n    rows[rows.length - 1] += x;\n\n    if (ESCAPES.indexOf(x) !== -1) {\n      insideEscape = true;\n    } else if (insideEscape && x === 'm') {\n      insideEscape = false;\n      continue;\n    }\n\n    if (insideEscape) {\n      continue;\n    }\n\n    visible++;\n\n    if (visible >= cols && i < word.length - 1) {\n      rows.push('');\n      visible = 0;\n    }\n  } // it's possible that the last row we copy over is only\n  // ansi escape characters, handle this edge-case.\n\n\n  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n    rows[rows.length - 2] += rows.pop();\n  }\n} // the wrap-ansi module can be invoked\n// in either 'hard' or 'soft' wrap mode.\n//\n// 'hard' will never allow a string to take up more\n// than cols characters.\n//\n// 'soft' allows long words to expand past the column length.\n\n\nfunction exec(str, cols, opts) {\n  var options = opts || {};\n  var pre = '';\n  var ret = '';\n  var escapeCode;\n  var lengths = wordLengths(str);\n  var words = str.split(' ');\n  var rows = [''];\n\n  for (var i = 0, word; (word = words[i]) !== undefined; i++) {\n    var rowLength = stringWidth(rows[rows.length - 1]);\n\n    if (rowLength) {\n      rows[rows.length - 1] += ' ';\n      rowLength++;\n    } // in 'hard' wrap mode, the length of a line is\n    // never allowed to extend past 'cols'.\n\n\n    if (lengths[i] > cols && options.hard) {\n      if (rowLength) {\n        rows.push('');\n      }\n\n      wrapWord(rows, word, cols);\n      continue;\n    }\n\n    if (rowLength + lengths[i] > cols && rowLength > 0) {\n      if (options.wordWrap === false && rowLength < cols) {\n        wrapWord(rows, word, cols);\n        continue;\n      }\n\n      rows.push('');\n    }\n\n    rows[rows.length - 1] += word;\n  }\n\n  pre = rows.map(function (r) {\n    return r.trim();\n  }).join('\\n');\n\n  for (var j = 0; j < pre.length; j++) {\n    var y = pre[j];\n    ret += y;\n\n    if (ESCAPES.indexOf(y) !== -1) {\n      var code = parseFloat(/[0-9][^m]*/.exec(pre.slice(j, j + 4)));\n      escapeCode = code === END_CODE ? null : code;\n    }\n\n    if (escapeCode && ESCAPE_CODES[escapeCode]) {\n      if (pre[j + 1] === '\\n') {\n        ret += wrapAnsi(ESCAPE_CODES[escapeCode]);\n      } else if (y === '\\n') {\n        ret += wrapAnsi(escapeCode);\n      }\n    }\n  }\n\n  return ret;\n} // for each line break, invoke the method separately.\n\n\nmodule.exports = function (str, cols, opts) {\n  return String(str).split('\\n').map(function (substr) {\n    return exec(substr, cols, opts);\n  }).join('\\n');\n};","map":null,"metadata":{},"sourceType":"script"}